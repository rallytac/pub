<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<meta name="generator" content="Doxygen 1.8.18"/>
		<meta name="viewport" content="width=device-width, initial-scale=1"/>
		<title>Engage Engine API: Asynchronous work helpers</title>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="custom_dark_theme.css" rel="stylesheet" type="text/css"/>
	</head>
	<body>
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
			<table cellspacing="0" cellpadding="0">
				<tbody>
					<tr style="height: 56px;">
						<td id="projectalign" style="padding-left: 0.5em;">
							<div id="projectname">Engage Engine API
								&#160;<span id="projectnumber">1.221.9059</span>
							</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part --><!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_nodejs_node_modules_nan_doc_asyncworker.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Asynchronous work helpers </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><code><a class="el" href="class_nan_1_1_async_worker.html">Nan::AsyncWorker</a></code>, <code>Nan::AsyncProgressWorker</code> and <code><a class="el" href="class_nan_1_1_async_progress_queue_worker.html">Nan::AsyncProgressQueueWorker</a></code> are helper classes that make working with asynchronous code easier.</p>
<ul>
<li><a href="#api_nan_async_worker"><b><code>Nan::AsyncWorker</code></b></a></li>
<li><a href="#api_nan_async_progress_worker"><b><code>Nan::AsyncProgressWorkerBase &amp; Nan::AsyncProgressWorker</code></b></a></li>
<li><a href="#api_nan_async_progress_queue_worker"><b><code>Nan::AsyncProgressQueueWorker</code></b></a></li>
<li><a href="#api_nan_async_queue_worker"><b><code>Nan::AsyncQueueWorker</code></b></a></li>
</ul>
<p><a class="anchor" id="api_nan_async_worker"></a> </p>
<h2><a class="anchor" id="autotoc_md805"></a>
Nan::AsyncWorker</h2>
<p><code><a class="el" href="class_nan_1_1_async_worker.html">Nan::AsyncWorker</a></code> is an <em>abstract</em> class that you can subclass to have much of the annoying asynchronous queuing and handling taken care of for you. It can even store arbitrary V8 objects for you and have them persist while the asynchronous work is in progress.</p>
<p>This class internally handles the details of creating an <a href="node_misc.md#api_nan_asyncresource"><code>AsyncResource</code></a>, and running the callback in the correct async context. To be able to identify the async resources created by this class in async-hooks, provide a <code>resource_name</code> to the constructor. It is recommended that the module name be used as a prefix to the <code>resource_name</code> to avoid collisions in the names. For more details see <a href="node_misc.md#api_nan_asyncresource"><code>AsyncResource</code></a> documentation. The <code>resource_name</code> needs to stay valid for the lifetime of the worker instance.</p>
<p>Definition:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">class AsyncWorker {</div>
<div class="line"> public:</div>
<div class="line">  explicit AsyncWorker(Callback *callback_, const char* resource_name = &quot;nan:AsyncWorker&quot;);</div>
<div class="line"> </div>
<div class="line">  virtual ~AsyncWorker();</div>
<div class="line"> </div>
<div class="line">  virtual void WorkComplete();</div>
<div class="line"> </div>
<div class="line">  void SaveToPersistent(const char *key, const v8::Local&lt;v8::Value&gt; &amp;value);</div>
<div class="line"> </div>
<div class="line">  void SaveToPersistent(const v8::Local&lt;v8::String&gt; &amp;key,</div>
<div class="line">                        const v8::Local&lt;v8::Value&gt; &amp;value);</div>
<div class="line"> </div>
<div class="line">  void SaveToPersistent(uint32_t index,</div>
<div class="line">                        const v8::Local&lt;v8::Value&gt; &amp;value);</div>
<div class="line"> </div>
<div class="line">  v8::Local&lt;v8::Value&gt; GetFromPersistent(const char *key) const;</div>
<div class="line"> </div>
<div class="line">  v8::Local&lt;v8::Value&gt; GetFromPersistent(const v8::Local&lt;v8::String&gt; &amp;key) const;</div>
<div class="line"> </div>
<div class="line">  v8::Local&lt;v8::Value&gt; GetFromPersistent(uint32_t index) const;</div>
<div class="line"> </div>
<div class="line">  virtual void Execute() = 0;</div>
<div class="line"> </div>
<div class="line">  uv_work_t request;</div>
<div class="line"> </div>
<div class="line">  virtual void Destroy();</div>
<div class="line"> </div>
<div class="line"> protected:</div>
<div class="line">  Persistent&lt;v8::Object&gt; persistentHandle;</div>
<div class="line"> </div>
<div class="line">  Callback *callback;</div>
<div class="line"> </div>
<div class="line">  virtual void HandleOKCallback();</div>
<div class="line"> </div>
<div class="line">  virtual void HandleErrorCallback();</div>
<div class="line"> </div>
<div class="line">  void SetErrorMessage(const char *msg);</div>
<div class="line"> </div>
<div class="line">  const char* ErrorMessage();</div>
<div class="line">};</div>
</div><!-- fragment --><p><a class="anchor" id="api_nan_async_progress_worker"></a> </p>
<h2><a class="anchor" id="autotoc_md806"></a>
Nan::AsyncProgressWorkerBase &amp; Nan::AsyncProgressWorker</h2>
<p><code><a class="el" href="class_nan_1_1_async_progress_worker_base.html">Nan::AsyncProgressWorkerBase</a></code> is an <em>abstract</em> class template that extends <code><a class="el" href="class_nan_1_1_async_worker.html">Nan::AsyncWorker</a></code> and adds additional progress reporting callbacks that can be used during the asynchronous work execution to provide progress data back to JavaScript.</p>
<p>Previously the definition of <code>Nan::AsyncProgressWorker</code> only allowed sending <code>const char</code> data. Now extending <code>Nan::AsyncProgressWorker</code> will yield an instance of the implicit <code><a class="el" href="class_nan_1_1_async_progress_worker_base.html">Nan::AsyncProgressWorkerBase</a></code> template with type <code>&lt;char&gt;</code> for compatibility.</p>
<p><code><a class="el" href="class_nan_1_1_async_progress_worker_base.html">Nan::AsyncProgressWorkerBase</a></code> &amp; <code>Nan::AsyncProgressWorker</code> is intended for best-effort delivery of nonessential progress messages, e.g. a progress bar. The last event sent before the main thread is woken will be delivered.</p>
<p>Definition:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">template&lt;class T&gt;</div>
<div class="line">class AsyncProgressWorkerBase&lt;T&gt; : public AsyncWorker {</div>
<div class="line"> public:</div>
<div class="line">  explicit AsyncProgressWorkerBase(Callback *callback_, const char* resource_name = ...);</div>
<div class="line"> </div>
<div class="line">  virtual ~AsyncProgressWorkerBase();</div>
<div class="line"> </div>
<div class="line">  void WorkProgress();</div>
<div class="line"> </div>
<div class="line">  class ExecutionProgress {</div>
<div class="line">   public:</div>
<div class="line">    void Signal() const;</div>
<div class="line">    void Send(const T* data, size_t count) const;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  virtual void Execute(const ExecutionProgress&amp; progress) = 0;</div>
<div class="line"> </div>
<div class="line">  virtual void HandleProgressCallback(const T *data, size_t count) = 0;</div>
<div class="line"> </div>
<div class="line">  virtual void Destroy();</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">typedef AsyncProgressWorkerBase&lt;T&gt; AsyncProgressWorker;</div>
</div><!-- fragment --><p><a class="anchor" id="api_nan_async_progress_queue_worker"></a> </p>
<h2><a class="anchor" id="autotoc_md807"></a>
Nan::AsyncProgressQueueWorker</h2>
<p><code><a class="el" href="class_nan_1_1_async_progress_queue_worker.html">Nan::AsyncProgressQueueWorker</a></code> is an <em>abstract</em> class template that extends <code><a class="el" href="class_nan_1_1_async_worker.html">Nan::AsyncWorker</a></code> and adds additional progress reporting callbacks that can be used during the asynchronous work execution to provide progress data back to JavaScript.</p>
<p><code><a class="el" href="class_nan_1_1_async_progress_queue_worker.html">Nan::AsyncProgressQueueWorker</a></code> behaves exactly the same as <code>Nan::AsyncProgressWorker</code>, except all events are queued and delivered to the main thread.</p>
<p>Definition:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">template&lt;class T&gt;</div>
<div class="line">class AsyncProgressQueueWorker&lt;T&gt; : public AsyncWorker {</div>
<div class="line"> public:</div>
<div class="line">  explicit AsyncProgressQueueWorker(Callback *callback_, const char* resource_name = &quot;nan:AsyncProgressQueueWorker&quot;);</div>
<div class="line"> </div>
<div class="line">  virtual ~AsyncProgressQueueWorker();</div>
<div class="line"> </div>
<div class="line">  void WorkProgress();</div>
<div class="line"> </div>
<div class="line">  class ExecutionProgress {</div>
<div class="line">   public:</div>
<div class="line">    void Send(const T* data, size_t count) const;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  virtual void Execute(const ExecutionProgress&amp; progress) = 0;</div>
<div class="line"> </div>
<div class="line">  virtual void HandleProgressCallback(const T *data, size_t count) = 0;</div>
<div class="line"> </div>
<div class="line">  virtual void Destroy();</div>
<div class="line">};</div>
</div><!-- fragment --><p><a class="anchor" id="api_nan_async_queue_worker"></a> </p>
<h2><a class="anchor" id="autotoc_md808"></a>
Nan::AsyncQueueWorker</h2>
<p><code>Nan::AsyncQueueWorker</code> will run a <code><a class="el" href="class_nan_1_1_async_worker.html">Nan::AsyncWorker</a></code> asynchronously via libuv. Both the <code>execute</code> and <code>after_work</code> steps are taken care of for you. Most of the logic for this is embedded in <code><a class="el" href="class_nan_1_1_async_worker.html">Nan::AsyncWorker</a></code>.</p>
<p>Definition:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">void AsyncQueueWorker(AsyncWorker *);</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
		<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
			<ul>
				<li class="footer">
					Generated on Sun Apr 3 2022 12:33:25 for Engage Engine API by <a href="http://www.doxygen.org/index.html">
					<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18.
					Dark theme by <a href="http://majerle.eu" target="_new">Tilen Majerle</a>. All rights reserved.
				</li>
			</ul>
		</div>
		<script src="custom.js"></script>
	</body>
</html>